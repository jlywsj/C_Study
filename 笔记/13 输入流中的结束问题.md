## 输入流中的结束问题

> getchar，scanf等输入函数在输入过程中的读取和结束问题



### EOF

​	-- end of file的缩写，表示“文字流“（stream）的结尾。这里的文字流，可以是文件，也可以

是标准输入(stdin)。通常在文本的最后存在此字符表示结束。在C语言中EOF是用#define定义在标准库中的一个define常量。

在c语言中使用输入时，会在内存中开辟一个缓冲区，将输入的内容存入缓冲区，当遇到scanf函数等函数时，scanf函数会从缓冲区中进行读取，当读取到结束的字符时结束，但是不会将结束字符读取掉，此时结束字符依然停留在缓冲区。当后面再进行读取时，结束字符将会被下一次读取到，如果此时是getchar函数读取，则会将结束字符读取走，如果是scanf函数，则会遇到结束字符而停止。

**getchar()会读取每一个字符包括回车和空格等**

**scanf()遇到结束符会结束，但是不读取结束符，结束符依旧保存在序列中，有返回值为读取的个数**

scanf函数执行时，会忽略缓冲区头部的空字符，scanf是读数据直到看见空白符就停止的输入函数

一般在scanf函数的后面会添加一个getchar()来清除缓冲区留下的\n等空字符

> scanf 和 getchar 等函数会在 stdin 中读取数据，若上述缓冲区中已存在数据，则直接读取其中的数据，若上述缓冲区为空，则上述函数会挂起，等待数据缓冲的完成( 用户输入回车键或数据缓冲区满后， stdin 会进行数据缓冲，之后上述函数才能继续执行)。 用户一次输入的数据可能会超过 scanf 、getchar 等函数调用所需要的数据，那么所需数据被读取后，剩余的数据仍会存放在缓冲区中，之后的函数调用会直接读取 stdin 中已有的数据。只有当缓冲区为空后，scanf 等函数才会等待用户输入(实际应该是等待 stdin 的缓冲。
> ————————————————
> 版权声明：本文为CSDN博主「沸腾石灰」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/m0_37738838/article/details/109912584